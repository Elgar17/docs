(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{455:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"高性能-javascript-代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高性能-javascript-代码"}},[t._v("#")]),t._v(" 高性能 JavaScript 代码")]),t._v(" "),s("p",[t._v("这里会介绍一些 javascript 中的一些最佳实践，之前看《高性能JavaScript 代码》这本书时记录的，这本书写的比较早，有些内容现在使用可能不适合，我就把最有用的记录了一下。")]),t._v(" "),s("h2",{attrs:{id:"_1-javascript-放在-body-的最后"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-javascript-放在-body-的最后"}},[t._v("#")]),t._v(" 1. javascript 放在 body 的最后")]),t._v(" "),s("p",[t._v("放在前面会阻塞页面的渲染，不过添加 defer 属性可以一步加载，这样不会阻塞页面。")]),t._v(" "),s("p",[t._v("要注意的是，默认情况下 js 文件加载后会立即执行，添加 defer 属性后等到页面加载完毕（onload 事件被触发）时，执行。")]),t._v(" "),s("h2",{attrs:{id:"_2-尽可能减少-http-请求的数量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-尽可能减少-http-请求的数量"}},[t._v("#")]),t._v(" 2. 尽可能减少 http 请求的数量")]),t._v(" "),s("p",[t._v("http 头部也是需要一定的开销，所以 下载一个 100KB 的文件比下载 4 个250KB 快。")]),t._v(" "),s("p",[t._v("css 使用雪碧图是这个原理")]),t._v(" "),s("h2",{attrs:{id:"_3-使用-ajax-加载脚本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用-ajax-加载脚本"}},[t._v("#")]),t._v(" 3. 使用 AJAX 加载脚本")]),t._v(" "),s("p",[t._v("AJAX 我们都知道是异步请求，我们通过一步请求脚本之后动态添加 js 脚本即可。")]),t._v(" "),s("p",[t._v("我们也可以使用 AJAX 请求传输多个图片，CSS，JS和HTML等资源文件，将多个资源合并到一个请求中会减少页面请求次数来提高页面性能，需要注意的是 AJAX 不能直接传输这些文件，而是将这些文件转换成 base64 编码转换后进行传输，资源文件不能被缓存。")]),t._v(" "),s("h2",{attrs:{id:"_4-使用-dom-选择器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用-dom-选择器"}},[t._v("#")]),t._v(" 4. 使用 DOM 选择器")]),t._v(" "),s("p",[t._v("这里比较 "),s("code",[t._v("querySlectorAll")]),t._v(" 和 "),s("code",[t._v("getElementById")]),t._v(", "),s("code",[t._v("getElementByTagName")]),t._v(" 方法比较。需要组合查询使用 "),s("code",[t._v("querySlectorAll")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 选择 id 为 menu 的 a 元素")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v("  menu "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" documnet"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"menu"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementByTagName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 效率会高一些")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 选择 class 为 btn 和 bg-red 的 div 元素")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v("  btn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" documnet"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("querySlectorAll")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'div.btn,div.bg-red'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h2",{attrs:{id:"_5-重绘与重排"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-重绘与重排"}},[t._v("#")]),t._v(" 5. 重绘与重排")]),t._v(" "),s("p",[t._v("浏览器下载完页面之后，会解析成两个内部结构：")]),t._v(" "),s("ul",[s("li",[t._v("DOM树：表示页面结构")]),t._v(" "),s("li",[t._v("渲染树：表示 DOM 节点如何显示")])]),t._v(" "),s("p",[t._v("渲染树包含元素的宽高，位置等信息，生成渲染树之后，浏览器开始渲染页面，这个过程中先触发“重排（reflow）”，重排后浏览器重新绘制收影响的部分到屏幕中，这过程成为“重绘（repaint）”。")]),t._v(" "),s("p",[t._v("所以说，触发重排必须触发重绘，重排在重绘前面。重绘不触发重排。")]),t._v(" "),s("p",[t._v("重排和重绘都是消耗性能的操作，所以尽量避免页面重排和重绘。能重绘完成的操作不要触发重绘。")]),t._v(" "),s("p",[t._v("以下情况下会重排")]),t._v(" "),s("ul",[s("li",[t._v("可见 DOM 元素的增删")]),t._v(" "),s("li",[t._v("改变位置")]),t._v(" "),s("li",[t._v("改变尺寸")]),t._v(" "),s("li",[t._v("页面处渲染")]),t._v(" "),s("li",[t._v("窗口尺寸改变")]),t._v(" "),s("li",[t._v("offsetTop")]),t._v(" "),s("li",[t._v("scrolTop")]),t._v(" "),s("li",[t._v("clientTop")])]),t._v(" "),s("h2",{attrs:{id:"_6-浏览器缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-浏览器缓存"}},[t._v("#")]),t._v(" 6. 浏览器缓存")]),t._v(" "),s("p",[t._v("在服务端设置 HTTP 头信息，可以将资源缓存到本地，可以使用 expires 请求头设置过期时间。也可以使用本地缓存 LocalStorage 和 cookie 等存储机制在前端也可以进行存储。")]),t._v(" "),s("h2",{attrs:{id:"_7-eval-双重运算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-eval-双重运算"}},[t._v("#")]),t._v(" 7. eval 双重运算")]),t._v(" "),s("p",[t._v("尽量不要使用 eval 函数运行 JS 代码，eval 是代价昂贵的操作，而且存在安全隐患（XSS）。")]),t._v(" "),s("h2",{attrs:{id:"_8-使用位操作符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-使用位操作符"}},[t._v("#")]),t._v(" 8. 使用位操作符")]),t._v(" "),s("p",[t._v("位操作是跟接近底层的，在其他语言中也一样，运行效率都很高效，有些场景可以适当使用位操作符来提高运算效率。")]),t._v(" "),s("p",[t._v("参考：")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://book.douban.com/subject/5362856/",target:"_blank",rel:"noopener noreferrer"}},[t._v("高性能 javascript"),s("OutboundLink")],1)])]),t._v(" "),s("comment-comment")],1)}),[],!1,null,null,null);a.default=r.exports}}]);